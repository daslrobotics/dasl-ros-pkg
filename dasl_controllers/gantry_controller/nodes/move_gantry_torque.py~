#!/usr/bin/env python

PKG = 'gantry_controller'

import roslib; roslib.load_manifest(PKG)

import time
from threading import Thread

import rospy
from geometry_msgs.msg import Twist
from sensor_msgs.msg import JointState

class MoveGantryTorque():
    def __init__(self):
        self.is_running = True
        self.step_size = 0.1
	self.gantry_cmd_vel = Twist()
        self.joint_states = None
       
        rospy.init_node('move_gantry_torque', log_level=rospy.INFO)
        rospy.Subscriber('joint_states', JointState, self.joint_state_handler)
	self.gantry_cmd_vel_pub = rospy.Publisher('cmd_vel', Twist)

    def joint_state_handler(self, msg):
	self.joint_states = msg

    def update_gantry_velocity(self):
        while self.is_running:
	    if self.joint_states:
                torque_roll = round(self.joint_states.effort[2],0)
                torque_pitch = round(self.joint_states.effort[1],0)
                torque_yaw = round(self.joint_states.effort[0],0)

		print torque_roll
		
		if ((torque_roll > 1) or (torque_roll < -1)):
                    self.gantry_cmd_vel.linear.y = 1 * torque_roll * self.step_size
                else:
		    self.gantry_cmd_vel.linear.y = 0

		if ((torque_pitch > 5) or (torque_pitch < -5)):
                    self.gantry_cmd_vel.linear.x = 1 * torque_pitch * self.step_size
                else:
		    self.gantry_cmd_vel.linear.x = 0

	    self.gantry_cmd_vel_pub.publish(self.gantry_cmd_vel)
            time.sleep(0.02)

if __name__ == '__main__':
    try:
        move_gantry = MoveGantryTorque()
        t = Thread(target=move_gantry.update_gantry_velocity)
        t.start()
        rospy.spin()
        move_gantry.is_running = False
        t.join()
    except rospy.ROSInterruptException: pass
